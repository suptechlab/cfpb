// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var Promise, conf, couch_utils, doAction, process_req, request, resources, teams, utils, uuid, validation, _;

  couch_utils = require('../couch_utils');

  utils = require('../utils');

  request = require('request');

  uuid = require('node-uuid');

  _ = require('underscore');

  Promise = require('pantheon-helpers').promise;

  doAction = require('pantheon-helpers').doAction;

  validation = require('../validation');

  conf = require('../config');

  resources = {
    gh: require('../workers/gh'),
    moirai: require('../workers/moirai')
  };

  process_req = function(req) {
    var db, org_db_name, params, team_name;
    params = req.params;
    org_db_name = 'org_' + params.org_id;
    team_name = params.team_id;
    db = req.couch.use(org_db_name);
    return [db, team_name, params];
  };

  teams = {};

  teams.create_team = function(db, team_name, callback) {
    return doAction(db, 'base', null, {
      a: 't+',
      name: team_name
    }, callback);
  };

  teams.handle_create_team = function(req, resp) {
    var db, params, team_name, _ref;
    _ref = process_req(req), db = _ref[0], team_name = _ref[1], params = _ref[2];
    return teams.create_team(db, team_name).on('response', function(couch_resp) {
      if (couch_resp.statusCode === 409) {
        return teams.get_team(db, team_name).pipe(resp);
      } else {
        resp.status(couch_resp.statusCode);
        return couch_resp.pipe(resp);
      }
    });
  };

  teams.get_team = function(org_db, team_name, callback) {
    return couch_utils.rewrite(org_db, 'base', '/teams/team_' + team_name, callback);
  };

  teams.handle_get_team = function(req, resp) {
    var db, params, team_name, _ref;
    _ref = process_req(req), db = _ref[0], team_name = _ref[1], params = _ref[2];
    return teams.get_team(db, team_name).pipe(resp);
  };

  teams.get_teams = function(org_db, callback) {
    return couch_utils.rewrite(org_db, 'base', '/teams', callback);
  };

  teams.handle_get_teams = function(req, resp) {
    var db;
    db = process_req(req)[0];
    return teams.get_teams(db).pipe(resp);
  };

  teams.get_all_teams = function() {
    return utils.get_org_dbs().then(function(org_ids) {
      var all_teams;
      all_teams = org_ids.map(function(org_id) {
        var org_db;
        org_db = couch_utils.nano_system_user.use(org_id);
        return teams.get_teams(org_db, 'promise');
      });
      return Promise.all(all_teams);
    }).then(function(all_teams) {
      all_teams = _.flatten(all_teams, true);
      return Promise.resolve(all_teams);
    });
  };

  teams.get_team_roles_for_user = function(db, user_name, callback) {

    /*
    return an array of team/role hashes to which the user belongs:
      [{team: <obj>, role: <str>}]
     */
    return db.viewWithList('base', 'by_role', 'get_team_roles', {
      include_docs: true,
      startkey: [user_name],
      endkey: [user_name, {}]
    }, callback);
  };

  teams.get_all_team_roles_for_user = function(user_name) {
    return utils.get_org_dbs('promise').then(function(org_ids) {
      var team_roles;
      team_roles = org_ids.map(function(org_id) {
        var db;
        db = couch_utils.nano_system_user.use(org_id);
        return teams.get_team_roles_for_user(db, user_name, 'promise');
      });
      return Promise.all(team_roles);
    }).then(function(team_roles) {
      team_roles = _.flatten(team_roles, true);
      return Promise.resolve(team_roles);
    });
  };

  teams.add_member = function(db, team_name, role, user_id, callback) {
    var team_id;
    team_id = 'team_' + team_name;
    return doAction(db, 'base', team_id, {
      a: 'u+',
      role: role,
      user: user_id
    }, callback);
  };

  teams.remove_member = function(db, team_name, role, user_id, callback) {
    var team_id;
    team_id = 'team_' + team_name;
    return doAction(db, 'base', team_id, {
      a: 'u-',
      role: role,
      user: user_id
    }, callback);
  };

  teams.add_asset = function(db, actor_name, team_name, resource, asset_data) {
    var users;
    users = require('./users');
    return Promise.all([teams.get_team(db, team_name, 'promise'), users.get_user(actor_name, 'promise')]).then(function(_arg) {
      var actor, handler, isAuthorized, team, _ref;
      team = _arg[0], actor = _arg[1];
      isAuthorized = validation.auth.add_team_asset(actor, team, resource);
      if (!isAuthorized) {
        return Promise.reject({
          code: 401,
          error: 'unauthorized',
          msg: 'You are not authorized to add this asset'
        });
      }
      handler = (_ref = resources[resource]) != null ? _ref.getOrCreateAsset : void 0;
      if (!handler) {
        return Promise.reject({
          code: 404,
          error: "not_found",
          msg: 'Resource, ' + resource + ', not found.'
        });
      }
      return handler(asset_data, team, actor).then(function(new_asset) {
        if (new_asset == null) {
          return Promise.resolve(team);
        } else {
          return doAction(db, 'base', team._id, {
            a: 'a+',
            resource: resource,
            asset: new_asset
          }, 'promise');
        }
      });
    })["catch"](function(err) {
      console.error('add_asset_error', resource, asset_data, err);
      return Promise.reject(err);
    });
  };

  teams.remove_asset = function(db, team_name, resource, asset_id, callback) {
    var team_id;
    team_id = 'team_' + team_name;
    return doAction(db, 'base', team_id, {
      a: 'a-',
      resource: resource,
      asset: {
        id: asset_id
      }
    }, callback);
  };

  teams.handle_add_member = function(req, resp) {
    var db, params, team_name, _ref;
    _ref = process_req(req), db = _ref[0], team_name = _ref[1], params = _ref[2];
    return teams.add_member(db, team_name, params.role, params.user_id).pipe(resp);
  };

  teams.handle_remove_member = function(req, resp) {
    var db, params, team_name, _ref;
    _ref = process_req(req), db = _ref[0], team_name = _ref[1], params = _ref[2];
    return teams.remove_member(db, team_name, params.role, params.user_id).pipe(resp);
  };

  teams.handle_add_asset = function(req, resp) {
    var db, params, team_name, _ref;
    _ref = process_req(req), db = _ref[0], team_name = _ref[1], params = _ref[2];
    return teams.add_asset(db, req.session.user, team_name, params.resource, req.body).then(function(team) {
      return resp.send(JSON.stringify(team));
    })["catch"](function(err) {
      if (err.code) {
        return resp.status(err.code).send(JSON.stringify(_.pick(err, 'error', 'msg')));
      } else {
        return resp.status(500).send(JSON.stringify({
          error: 'server error',
          msg: 'something went wrong. please try again.'
        }));
      }
    });
  };

  teams.handle_remove_asset = function(req, resp) {
    var db, params, team_name, _ref;
    _ref = process_req(req), db = _ref[0], team_name = _ref[1], params = _ref[2];
    return teams.remove_asset(db, team_name, params.resource, params.asset_id).pipe(resp);
  };

  teams.get_team_details = function(db, team_name, actor_name) {
    var users;
    users = require('./users');
    return Promise.all([teams.get_team(db, team_name, 'promise'), users.get_user(actor_name, 'promise')]).then(function(_arg) {
      var actor, rsrcs_promises, team;
      team = _arg[0], actor = _arg[1];
      rsrcs_promises = {};
      _.forEach(team.rsrcs, function(resource_data, resource_name) {
        var assets, detailHandler;
        detailHandler = resources[resource_name].getTeamAssetDetails;
        if (detailHandler) {
          assets = resource_data.assets;
          return rsrcs_promises[resource_name] = detailHandler(assets, team, actor).then(function(asset_details) {
            var zipped_assets;
            zipped_assets = _.zip(assets, asset_details);
            _.each(zipped_assets, function(_arg1) {
              var asset_data, asset_details;
              asset_data = _arg1[0], asset_details = _arg1[1];
              return asset_data.details = asset_details;
            });
            return Promise.resolve(assets);
          });
        } else {
          return rsrcs_promises[resource_name] = Promise.resolve([]);
        }
      });
      return Promise.hashAll(rsrcs_promises).then(function(rsrcs) {
        return Promise.resolve({
          rsrcs: rsrcs
        });
      });
    });
  };

  teams.handle_get_team_details = function(req, resp) {
    var db, params, team_name, _ref;
    _ref = process_req(req), db = _ref[0], team_name = _ref[1], params = _ref[2];
    return teams.get_team_details(db, team_name, req.session.user).then(function(team_details) {
      return resp.send(JSON.stringify(team_details));
    }, function(err) {
      console.log('handle_get_team_details error', team_name, err);
      if (err.statusCode) {
        return resp.status(err.statusCode).send(JSON.stringify(_.pick(err, 'error', 'reason')));
      } else {
        return resp.status(500).send(JSON.stringify({
          error: 'server error',
          msg: 'something went wrong. please try again.'
        }));
      }
    });
  };

  teams.handle_proxy_action = function(req, resp) {
    var db, params, team_name, users, _ref;
    _ref = process_req(req)(users = require('./users')), db = _ref[0], team_name = _ref[1], params = _ref[2];
    return Promise.all([teams.get_team(db, team_name, 'promise'), users.get_user(req.session.user, 'promise')]).then(function(_arg) {
      var actor, asset, assets, e, resource, status, team, _ref1, _ref2;
      team = _arg[0], actor = _arg[1];
      resource = params.resource;
      assets = (_ref1 = team.rsrcs) != null ? (_ref2 = _ref1[resource]) != null ? _ref2.assets : void 0 : void 0;
      asset = _.findWhere(assets, {
        id: params.asset_id
      });
      if (!asset) {
        resp.status(404).send({
          error: "not_found",
          msg: 'Asset, ' + resource + ' ' + params.asset_id + ', not found.'
        });
      }
      try {
        validation.proxy_asset_action(actor, team, resource, asset, params.path, req.method, req.body, req);
      } catch (_error) {
        e = _error;
        status = {
          unauthorized: 401,
          invalid: 403
        }[e.state];
        return resp.status(status).send(JSON.stringify({
          err: e.state,
          msg: e.err
        }));
      }
      return resources[resource].doAssetAction(actor, team, resource, asset, params.path, req.method, req.body, req, resp);
    });
  };

  module.exports = teams;

}).call(this);
