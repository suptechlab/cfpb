// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var Promise, couch_utils, s, x, _;

  _ = require('underscore');

  s = require('underscore.string');

  couch_utils = require('./couch_utils');

  Promise = require('pantheon-helpers').promise;

  x = {};

  x.denodeify_all = function(obj) {
    var k, out, v, _results;
    out = {};
    _results = [];
    for (k in obj) {
      v = obj[k];
      if (_.isFunction(v)) {
        _results.push(out[k] = Promise.denodeify(v));
      } else if (_.isObject(v) && !_.isArray(v)) {
        _results.push(out[k] = x.denodeify_all(v));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  x.denodeify_api = function(obj) {
    var k, pName, v, _results;
    _results = [];
    for (k in obj) {
      v = obj[k];
      if (_.isFunction(v) && !s.startsWith(k, 'handle')) {
        pName = 'p' + s.capitalize(k);
        _results.push(obj[pName] = Promise.denodeify(v));
      } else if (_.isObject(v) && !_.isArray(v)) {
        _results.push(x.denodeify_api(v));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  x.compact_hash = function(hash) {

    /*
    given a hash return a new hash with only non-falsy values. 
    if the hash will be empty, return undefined
     */
    var out;
    out = _.pick(hash, _.identity);
    if (_.isEmpty(out)) {
      return void 0;
    } else {
      return out;
    }
  };

  x.get_org_dbs = function() {

    /*
    return promise only
    return all organization databases
     */
    return couch_utils.nano_system_user.db.list('promise').then(function(dbs) {
      var out;
      out = _.filter(dbs, function(x) {
        return x.indexOf('org_') === 0;
      });
      return Promise.resolve(out);
    });
  };

  module.exports = x;

}).call(this);
