// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var v, _;

  _ = require('underscore');

  v = {
    validate_doc_update: function(validation_fns, get_doc_type, should_skip_validation_for_user) {
      should_skip_validation_for_user || (should_skip_validation_for_user = function() {
        return false;
      });
      return function(new_doc, old_doc, user_ctx, sec_obj) {
        var actions, doc_type, new_audit_entries;
        doc_type = get_doc_type(old_doc || new_doc);
        actions = validation_fns[doc_type];
        new_audit_entries = v.get_new_audit_entries(new_doc, old_doc);
        if (should_skip_validation_for_user(user_ctx) || !actions || !new_audit_entries.length) {
          return;
        }
        return v.validate_audit_entries(actions, new_audit_entries, user_ctx, old_doc, new_doc);
      };
    },
    get_new_audit_entries: function(new_doc, old_doc) {
      var new_entries, new_log, old_entries, old_log;
      new_log = new_doc.audit || [];
      old_log = old_doc ? old_doc.audit : [];
      new_entries = new_log.slice(old_log.length);
      if (!new_entries.length) {
        return new_entries;
      }
      old_entries = new_log.slice(0, old_log.length);
      if (!_.isEqual(old_log, old_entries)) {
        throw {
          forbidden: 'Entries are immutable. original entries: ' + JSON.stringify(old_log) + '; modified entries: ' + JSON.stringify(old_entries) + '.'
        };
      }
      return new_entries;
    },
    validate_audit_entries: function(actions, new_audit_entries, actor, old_doc, new_doc) {
      return new_audit_entries.forEach(function(entry) {
        return v.validate_audit_entry(actions, entry, actor, old_doc, new_doc);
      });
    },
    validate_audit_entry: function(actions, entry, actor, old_doc, new_doc) {
      var authorized, e;
      if (entry.u !== actor.name) {
        throw {
          forbidden: 'User performing action (' + entry.u + ') does not match logged in user (' + actor.name + ').'
        };
      }
      if (!(entry.a in actions)) {
        throw {
          forbidden: 'Invalid action: ' + entry.a + '.'
        };
      }
      try {
        return authorized = actions[entry.a](entry, actor, old_doc, new_doc) || false;
      } catch (_error) {
        e = _error;
        if (e.state === 'unauthorized') {
          throw {
            unauthorized: e.err
          };
        } else {
          throw {
            forbidden: e.err
          };
        }
      }
    }
  };

  module.exports = v;

}).call(this);
