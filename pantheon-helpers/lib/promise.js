// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var Promise, exec, parse_links, request, resolve, timers, utils, _,
    __slice = [].slice;

  Promise = require('promise');

  _ = require('underscore');

  request = require('request');

  resolve = require('url').resolve;

  parse_links = require('parse-links');

  utils = require('./utils');

  timers = require('timers');

  exec = require('child_process').exec;

  Promise.resolveAll = function(promiseArray) {
    "resolve all promises in the passed array.\nunlike Promise.all(array), does not fail upon first failure.\nInstead, each promise resolves to an object:\n  {state: \"resolved|rejected\", value|error: resp} ";
    var resolvedPromiseArray;
    resolvedPromiseArray = promiseArray.map(function(promise) {
      return promise.then(function(resp) {
        return Promise.resolve({
          state: 'resolved',
          value: resp
        });
      }, function(err) {
        return Promise.resolve({
          state: 'rejected',
          error: err
        });
      });
    });
    return Promise.all(resolvedPromiseArray);
  };

  Promise.hashResolveAll = function(promiseHash) {
    "given a hash of promises, always resolved to a hash\nof results with a state==resolved|rejected and the value/error";
    var keys, promises;
    keys = _.keys(promiseHash);
    promises = _.values(promiseHash);
    return Promise.resolveAll(promises).then(function(resps) {
      return Promise.resolve(_.object(keys, resps));
    });
  };

  Promise.hashAll = function(promiseHash) {
    "given a hash of promises, return a hash of resolved values,\nor return the first error";
    var keys, promises;
    keys = _.keys(promiseHash);
    promises = _.values(promiseHash);
    return Promise.all(promises).then(function(resps) {
      return Promise.resolve(_.object(keys, resps));
    });
  };

  Promise.RestClient = function(defaults) {

    /*
    pass in opts for a request client (https://github.com/request/request)
    responses will return promises, rather than streams.
    request url will be resolved using opts.url as a base, so you don't 
    have to pass in fully qualified urls every time
     */
    var Client, client;
    client = request.defaults(defaults);
    Client = {};
    ['get', 'put', 'post', 'del', 'head', 'patch'].forEach(function(method) {
      return Client[method] = Promise.denodeify(function(opts, callback) {
        if (typeof opts === 'string') {
          opts = {
            url: opts
          };
        }
        opts.url = resolve(defaults.url, opts.url);
        return client[method](opts, utils.process_resp(opts, callback));
      });
    });
    Client.get_all = function(opts) {

      /*
      get all results (following link headers)
      ** returns Promise **
       */
      var handle_get, results;
      if (typeof opts === 'string') {
        opts = {
          url: opts
        };
      }
      results = [];
      handle_get = function(resp) {
        var link_header, links;
        results = results.concat(resp.body);
        link_header = resp.headers.link;
        if (link_header != null) {
          links = parse_links(link_header);
        }
        opts.url = (links != null ? links.next : void 0) || null;
        if (opts.url) {
          return Client.get(opts).then(handle_get);
        } else {
          return Promise.resolve(results);
        }
      };
      return Client.get(opts).then(handle_get);
    };
    Client.find_one = function(opts, predicate) {

      /*
      keep getting results (using link headers)until we find 
      one that matches predicate or we reach last result.
      ** returns Promise **
       */
      var handle_get;
      if (typeof opts === 'string') {
        opts = {
          url: opts
        };
      }
      handle_get = function(resp) {
        var link_header, links, result;
        result = _.find(resp.body, predicate);
        link_header = resp.headers.link;
        if (link_header != null) {
          links = parse_links(link_header);
        }
        opts.url = (links != null ? links.next : void 0) || null;
        if (result || !opts.url) {
          return Promise.resolve(result);
        } else {
          return Client.get(opts).then(handle_get);
        }
      };
      return Client.get(opts).then(handle_get);
    };
    return Client;
  };

  Promise.setTimeout = Promise.denodeify(function() {
    var args, callback, delay, _i;
    delay = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), callback = arguments[_i++];
    return timers.setTimeout.apply(null, [callback, delay].concat(args));
  });

  Promise.exec = Promise.denodeify(exec);

  module.exports = Promise;

}).call(this);
