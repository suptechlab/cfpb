// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var u, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('underscore');

  u = {
    mk_objs: function(obj, path_array, val) {
      var path_part;
      if (val == null) {
        val = {};
      }

      /*
      make a set of nested object.
      
      obj = {'x': 1}
      mk_objs(obj, ['a', 'b'], ['1'])
       * returns []
       * obj now equals {'x': 1, 'a': {'b': ['1']}}
      
      return the val
       */
      if (!path_array.length) {
        return obj;
      }
      path_part = path_array.shift();
      if (!obj[path_part]) {
        if (path_array.length) {
          obj[path_part] = {};
        } else {
          obj[path_part] = val;
        }
      } else if (path_array.length && _.isArray(obj[path_part])) {
        throw new Error('item at "' + path_part + '" must be an Object, but it is an Array.');
      } else if (path_array.length && !_.isObject(obj[path_part])) {
        throw new Error('item at "' + path_part + '" must be an Object, but it is a ' + typeof obj[path_part] + '.');
      }
      return u.mk_objs(obj[path_part], path_array, val);
    }
  };

  u.process_resp = function(opts, callback) {

    /*
    process a request HTTP response. return a standardized
    error regardless of whether there was a transport error or a server error
    opts is a hash with an optional:
      ignore_codes - array of error codes to ignore, or if 'all' will ignore all http error codes
      body_only - boolean whether to return the body or the full response
     */
    var ignore_codes, is_http_err;
    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }
    ignore_codes = opts.ignore_codes || [];
    is_http_err = function(resp) {
      var _ref;
      if (ignore_codes === 'all' || resp.statusCode < 400 || (_ref = resp.statusCode, __indexOf.call(ignore_codes || [], _ref) >= 0)) {
        return false;
      } else {
        return true;
      }
    };
    return function(err, resp, body) {
      var req;
      if (err || is_http_err(resp)) {
        req = (resp != null ? resp.req : void 0) || {};
        req = _.pick(req, '_headers', 'path', 'method');
        err = {
          err: err,
          msg: body,
          code: resp != null ? resp.statusCode : void 0,
          req: req
        };
      }
      if (opts.body_only) {
        return callback(err, body);
      } else {
        return callback(err, resp, body);
      }
    };
  };

  u.deepExtend = function(target, source) {

    /*
    recursively extend an object.
    does not recurse into arrays
     */
    var k, sv, tv;
    for (k in source) {
      sv = source[k];
      tv = target[k];
      if (tv instanceof Array) {
        target[k] = sv;
      } else if (typeof tv === 'object' && typeof sv === 'object') {
        target[k] = u.deepExtend(tv, sv);
      } else {
        target[k] = sv;
      }
    }
    return target;
  };

  module.exports = u;

}).call(this);
