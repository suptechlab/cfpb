"""This sampling class facilitates the sampling of datetimes between a given range
following a particular distribution. By changing the format argument of init, the class 
can be configured to generate dates, datetimes, or times. This class utilizes 
ContinuousRandom as a parent class with additional logic added to facilitate the 
translation of datetimes and sampled values.

For example, this class can be used to sample dates between 20200101 and 20201231 
following a normal distribution. This sampling distribution would result in the bulk of 
returned date strings (formatted as %Y%m%d by default) to fall within the summer months.
"""

# TODO: It would be nice if the output format of generated samples could differ from
# those of the input. For example, suppose two dates are supplied with format %Y%m%d
# as the minimum and maximum values in the range. What if I wanted the output to be
# the weekday name (Monday, Tuesday, etc.) or just day of the month? This could be
# accomplished by renaming the format kwarg to `input_format` and adding a second option
# for those generated by generate_samples.

import time
from datetime import datetime
from typing import List, Iterable

from .BoundedNumerical import BoundedNumerical
from mock_data.backends.Correlation import Correlation


class BoundedDatetime(BoundedNumerical):
    def __init__(
        self,
        min_datetime: str,
        max_datetime: str,
        distribution: str = "uniform",
        format: str = "%Y%m%d",
        correlation: str = Correlation.INDEPENDENT.name,
        dep_field: str = None,
        **distribution_kwargs,
    ) -> None:
        """Wraps BoundedNumerical.__init__(...) to facilitate the mapping of the date
        strings to upper and lower numerical bounds. These bounds are set to the
        corresponding unix timestamps of min_datetime and max_datetime. The supplied
        datetime bounds must follow the supplied format. Returned sampled from
        generate_samples will also adhere to the supplied format string."""

        lower_bound = self._calculate_epoch_equivalent(min_datetime, format)
        upper_bound = self._calculate_epoch_equivalent(max_datetime, format)

        self.format = format

        super().__init__(distribution, lower_bound, upper_bound,
                         correlation=correlation, dep_field=dep_field,
                         **distribution_kwargs)

    @classmethod
    def _calculate_epoch_equivalent(cls, datetime_str: str, format: str) -> float:
        """Calculates the epoch timestap of the supplied datetime string using the
        datetime format supplied to the constructor of the class.

        Args:
            date_str (str): Datetime string supplied from constructor.
            format (str): Format of the datetime string. e.g. "%Y%m%d"


        Returns:
            float: Epoch timestamp of the supplied datetime string.
        """

        # this will raise a ValueError if conversion fails
        date = datetime.strptime(datetime_str, format)
        return int(time.mktime(date.timetuple()))


    def nums_to_dates(self, nums: Iterable):
        # convert these to datetime objects
        dt_objects = [datetime.fromtimestamp(ts) for ts in nums]

        # format each datetime object as a string and return
        return [datetime.strftime(dt, self.format) for dt in dt_objects]


    def generate_samples(self, size: int, directive: List = None) -> List[str]:
        """Generates `size` date strings with the format YYYYMMDD by sampling epoch
        timestamps and then converting those back to date strings.

        Args:
            size (int): Number of samples to generate

        Returns:
            List[str]: A list of date strings with size elements.
        """

        # Generate epoch timestamps using the underlying sampling engine and return as dates
        return self.nums_to_dates(super().generate_samples(size))
